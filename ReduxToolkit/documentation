Redux Toolkit

- npm install @reduxjs/toolkit react-redux
- slice: collection of actions and reducer login for different components of an app 
e.g. blogs ______________________________________________________________________________________________

a. redux-thunk
______________________________________________________________________________________________

link: https://www.youtube.com/watch?v=NqzdVN2tyvQ
https://www.dhiwise.com/post/redux-thunk-vs-redux-saga-choosing-the-right-middleware

Notes: 
- Redux Thunk middleware allows you to write action creators that return a function instead of an action.
- used to delay the dispatch of an action
- a standard approach to write async logic -> happens outside the store
- import : createAsyncThunk , axios

- extraReducers -> take in builder

- fetchAllPosts in slice -> async thunk action creator

- why use a builder?
1. Make code readable and maintainable Code: 
2. It allows concise syntax for defining reducers for different action types (pending, fulfilled, rejected).
3. The addCase method automatically handles action types generated by the async thunk action (fetchAllPosts.pending, fetchAllPosts.fulfilled, fetchAllPosts.rejected).

code reference: mypostsSlice.js



______________________________________________________________________________________________

a. redux-saga
______________________________________________________________________________________________

video link: https://www.youtube.com/watch?v=gu3FfmgkwUc&t=403s

> What are generators?
Notes:
- it is a type of iterator (that has a .next() method)
- has three things:
1. advances : .next()
2. pauses   :  yield  
3. stops    :  return

- take: This is another generator function that takes the first n elements from an iterable and yields them. 

- are iterables as well 
. yield concept
. anytime we try to iterate an object it looks for the [symbol.iterator]

- let us do lazy evaluation
- pausible functions so do not run infinitely
- for binary tree -> use in place of recursive function : yield*

- used for async calls

- can consume data
- if we send .next() call twice it remembers what was sent in the previous .next() 

- generators can pause and when we call .next() it starts running again












